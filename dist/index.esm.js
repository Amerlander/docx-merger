import B from"jszip";import{DOMParser as g,XMLSerializer as O}from"@xmldom/xmldom";var f=async function(l,e){let t=l.map(async n=>{let i=await n.file("word/styles.xml").async("string"),o=new g().parseFromString(i,"text/xml").documentElement.childNodes;for(let r=0;r<o.length;r++)if(o[r].nodeType===1){let a=o[r].getAttribute("w:styleId");e[a]||(e[a]=o[r].cloneNode(!0))}});return Promise.all(t)},p=async function(l,e){let t=l.map(async n=>{let i=await n.file("word/styles.xml").async("string"),s=new g().parseFromString(i,"text/xml"),o=new O,r=s.documentElement.cloneNode();for(let m in e)r.appendChild(e[m]);let a=i.indexOf("<w:styles");i=i.replace(i.slice(a),o.serializeToString(r)),n.file("word/styles.xml",i)});return Promise.all(t)};var w=async function(l,e){let t=await l.file("word/styles.xml").async("string"),n=t.indexOf("<w:style "),i=t.indexOf("</w:styles>");t=t.replace(t.slice(n,i),e.join("")),l.file("word/styles.xml",t)};import C from"jszip";import{DOMParser as v,XMLSerializer as L}from"@xmldom/xmldom";async function y(l,e){for(let t of l){let i=(await new C().loadAsync(t)).folder("word/media");i&&i.forEach((s,o)=>{e[s]=o})}}async function x(l,e,t){let n=l.folder("word/media");if(!n)throw new Error("Media folder not found in the zip");for(let[i,s]of Object.entries(e)){let o=await s.async("blob");n.file(i,o)}}import{DOMParser as c,XMLSerializer as u}from"@xmldom/xmldom";var h=function(l,e){let t=l.map(async n=>{let i=await n.file("[Content_Types].xml").async("string"),o=new c().parseFromString(i,"text/xml").getElementsByTagName("Types")[0].childNodes;for(let r in o)if(/^\d+$/.test(r)&&o[r].getAttribute){let a=o[r].getAttribute("ContentType");e[a]||(e[a]=o[r].cloneNode())}});return Promise.all(t)},b=async function(l,e){let t=l.map(async n=>{let i=await n.file("word/_rels/document.xml.rels").async("string"),o=new c().parseFromString(i,"text/xml").documentElement.childNodes;for(let r=0;r<o.length;r++)if(o[r].nodeType===1){let a=o[r].getAttribute("Id");e[a]||(e[a]=o[r].cloneNode())}});return Promise.all(t)},S=async function(l,e){let t=await l.file("[Content_Types].xml").async("string"),n=new c().parseFromString(t,"text/xml"),i=new u,s=n.documentElement.cloneNode();for(let r in e)s.appendChild(e[r]);let o=t.indexOf("<Types");t=t.replace(t.slice(o),i.serializeToString(s)),l.file("[Content_Types].xml",t)},_=async function(l,e){let t=await l.file("word/_rels/document.xml.rels").async("string"),n=new c().parseFromString(t,"text/xml"),i=new u,s=n.documentElement.cloneNode();for(let r in e)s.appendChild(e[r]);let o=t.indexOf("<Relationships");t=t.replace(t.slice(o),i.serializeToString(s)),l.file("word/_rels/document.xml.rels",t)};import"jszip";import{DOMParser as N,XMLSerializer as M}from"@xmldom/xmldom";async function T(l,e){let t=l.map(async n=>{let i=await n.file("word/numbering.xml").async("string"),o=new N().parseFromString(i,"text/xml").documentElement.childNodes;for(let r=0;r<o.length;r++)if(o[r].nodeType===1){let a=o[r].getAttribute("w:abstractNumId");e[a]||(e[a]=o[r].cloneNode(!0))}e.push(i)});return Promise.all(t)}async function I(l,e){let t=l.map(async n=>{let i=await n.file("word/numbering.xml").async("string"),s=new N().parseFromString(i,"text/xml"),o=new M,r=s.documentElement.cloneNode();for(let m in e)r.appendChild(e[m]);let a=i.indexOf("<w:numbering");i=i.replace(i.slice(a),o.serializeToString(r)),n.file("word/numbering.xml",i)});return Promise.all(t)}async function R(l,e){let t=l.file("word/numbering.xml");if(!t)throw new Error("Numbering file not found in the zip");let n=await t.async("string"),i=n.indexOf("<w:abstractNum "),s=n.indexOf("</w:numbering>");n=n.replace(n.slice(i,s),e.join("")),l.file("word/numbering.xml",n)}var d=class{constructor(e={},t=[]){this._body=[],this._header=[],this._footer=[],this._pageBreak=typeof e.pageBreak!="undefined"?!!e.pageBreak:!0,this._Basestyle=e.style||"source",this._style=[],this._numbering=[],this._files=[],this._contentTypes={},this._media={},this._rel={},this._builder=this._body,this.initialize(e,t)}async initialize(e,t){for(let n of t){let i=n instanceof Uint8Array?n.buffer:n,s=await new B().loadAsync(i);this._files.push(s)}this._files.length>0&&await this.mergeBody(this._files)}insertPageBreak(){let e='<w:p>                     <w:r>                         <w:br w:type="page"/>                     </w:r>                 </w:p>';this._builder.push(e)}insertSectionBreak(){let e='<w:p>                     <w:pPr>                         <w:sectPr>                             <w:type w:val="nextPage"/>                         </w:sectPr>                     </w:pPr>                 </w:p>';this._builder.push(e)}insertRaw(e){this._builder.push(e)}async mergeBody(e){this._builder=this._body,await h(e,this._contentTypes),await y(e,this._media),await b(e,this._rel),await T(e,this._numbering),await I(e,this._numbering),await f(e,this._style),await p(e,this._style);let t=e.map(async(n,i)=>{let s=await n.file("word/document.xml").async("string");s=s.substring(s.indexOf("<w:body>")+8),s=s.substring(0,s.indexOf("</w:body>")),s=s.substring(0,s.lastIndexOf("<w:sectPr")),this.insertRaw(s),this._pageBreak&&i<e.length-1&&this.insertSectionBreak()});return Promise.all(t).then(()=>{})}async save(e,t){let n=this._files[0];if(!n||!n.file)throw new Error("JSZip file not properly loaded");let i=await n.file("word/document.xml").async("string"),s=i.indexOf("<w:body>")+8,o=i.lastIndexOf("<w:sectPr");i=i.replace(i.slice(s,o),this._body.join("")),await S(n,this._contentTypes),await x(n,this._media,this._files),await _(n,this._rel),await R(n,this._numbering),await w(n,this._style),n.file("word/document.xml",i);let r=await n.generateAsync({type:e,compression:"DEFLATE",compressionOptions:{level:4}});return t&&t(r),r}},U=d;export{U as default};
//# sourceMappingURL=index.esm.js.map
