var g=(o=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(o,{get:(e,t)=>(typeof require!="undefined"?require:e)[t]}):o)(function(o){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+o+'" is not supported')});import D from"jszip";import{DOMParser as f,XMLSerializer as R}from"@xmldom/xmldom";var w=async function(o,e){let t=o.map(async n=>{let r=await n.file("word/styles.xml").async("string"),l=new f().parseFromString(r,"text/xml").documentElement.childNodes;for(let i=0;i<l.length;i++)if(l[i].nodeType===1){let a=l[i].getAttribute("w:styleId");e[a]||(e[a]=l[i].cloneNode(!0))}});return Promise.all(t)},p=async function(o,e){let t=o.map(async n=>{let r=await n.file("word/styles.xml").async("string"),s=new f().parseFromString(r,"text/xml"),l=new R,i=s.documentElement.cloneNode();for(let d in e)i.appendChild(e[d]);let a=r.indexOf("<w:styles");r=r.replace(r.slice(a),l.serializeToString(i)),n.file("word/styles.xml",r)});return Promise.all(t)};var y=async function(o,e){let t=await o.file("word/styles.xml").async("string"),n=t.indexOf("<w:style "),r=t.indexOf("</w:styles>");t=t.replace(t.slice(n,r),e.join("")),o.file("word/styles.xml",t)};import B from"jszip";import{DOMParser as j,XMLSerializer as J}from"@xmldom/xmldom";async function u(o,e){for(let t of o){let r=(await new B().loadAsync(t)).folder("word/media");r&&r.forEach((s,l)=>{e[s]=l})}}async function x(o,e,t){let n=o.folder("word/media");if(!n)throw new Error("Media folder not found in the zip");for(let[r,s]of Object.entries(e)){let l=await s.async("blob");n.file(r,l)}}import{DOMParser as c,XMLSerializer as h}from"@xmldom/xmldom";var b=function(o,e){let t=o.map(async n=>{let r=await n.file("[Content_Types].xml").async("string"),l=new c().parseFromString(r,"text/xml").getElementsByTagName("Types")[0].childNodes;for(let i in l)if(/^\d+$/.test(i)&&l[i].getAttribute){let a=l[i].getAttribute("ContentType");e[a]||(e[a]=l[i].cloneNode())}});return Promise.all(t)},S=async function(o,e){let t=o.map(async n=>{let r=await n.file("word/_rels/document.xml.rels").async("string"),l=new c().parseFromString(r,"text/xml").documentElement.childNodes;for(let i=0;i<l.length;i++)if(l[i].nodeType===1){let a=l[i].getAttribute("Id");e[a]||(e[a]=l[i].cloneNode())}});return Promise.all(t)},_=async function(o,e){let t=await o.file("[Content_Types].xml").async("string"),n=new c().parseFromString(t,"text/xml"),r=new h,s=n.documentElement.cloneNode();for(let i in e)s.appendChild(e[i]);let l=t.indexOf("<Types");t=t.replace(t.slice(l),r.serializeToString(s)),o.file("[Content_Types].xml",t)},N=async function(o,e){let t=await o.file("word/_rels/document.xml.rels").async("string"),n=new c().parseFromString(t,"text/xml"),r=new h,s=n.documentElement.cloneNode();for(let i in e)s.appendChild(e[i]);let l=t.indexOf("<Relationships");t=t.replace(t.slice(l),r.serializeToString(s)),o.file("word/_rels/document.xml.rels",t)};import"jszip";import{DOMParser as T,XMLSerializer as z}from"@xmldom/xmldom";async function I(o,e){let t=o.map(async n=>{let r=await n.file("word/numbering.xml").async("string"),l=new T().parseFromString(r,"text/xml").documentElement.childNodes;for(let i=0;i<l.length;i++)if(l[i].nodeType===1){let a=l[i].getAttribute("w:abstractNumId");e[a]||(e[a]=l[i].cloneNode(!0))}e.push(r)});return Promise.all(t)}async function M(o,e){let t=o.map(async n=>{let r=await n.file("word/numbering.xml").async("string"),s=new T().parseFromString(r,"text/xml"),l=new z,i=s.documentElement.cloneNode();for(let d in e)i.appendChild(e[d]);let a=r.indexOf("<w:numbering");r=r.replace(r.slice(a),l.serializeToString(i)),n.file("word/numbering.xml",r)});return Promise.all(t)}async function O(o,e){let t=o.file("word/numbering.xml");if(!t)throw new Error("Numbering file not found in the zip");let n=await t.async("string"),r=n.indexOf("<w:abstractNum "),s=n.indexOf("</w:numbering>");n=n.replace(n.slice(r,s),e.join("")),o.file("word/numbering.xml",n)}var P=typeof window!="undefined"&&typeof window.document!="undefined",H=P?window.XMLSerializer:g("@xmldom/xmldom").XMLSerializer,K=P?window.DOMParser:g("@xmldom/xmldom").DOMParser,m=class{constructor(){this._body=[],this._header=[],this._footer=[],this._pageBreak=!0,this._Basestyle="source",this._style=[],this._numbering=[],this._files=[],this._contentTypes={},this._media={},this._rel={},this._builder=this._body}async initialize(e={},t){t=t||[],this._pageBreak=typeof e.pageBreak!="undefined"?!!e.pageBreak:!0,this._Basestyle=e.style||"source";for(let n of t){let r=n instanceof Uint8Array?n.buffer:n;console.log("arrayBuffer",r);let s=await new D().loadAsync(r);this._files.push(s)}this._files.length>0&&await this.mergeBody(this._files)}insertPageBreak(){let e='<w:p>                     <w:r>                         <w:br w:type="page"/>                     </w:r>                 </w:p>';this._builder.push(e)}insertSectionBreak(){let e='<w:p>                     <w:pPr>                         <w:sectPr>                             <w:type w:val="nextPage"/>                         </w:sectPr>                     </w:pPr>                 </w:p>';this._builder.push(e)}insertRaw(e){this._builder.push(e)}async mergeBody(e){this._builder=this._body,await b(e,this._contentTypes),await u(e,this._media),await S(e,this._rel),await I(e,this._numbering),await M(e,this._numbering),await w(e,this._style),await p(e,this._style);let t=e.map(async(n,r)=>{let s=await n.file("word/document.xml").async("string");s=s.substring(s.indexOf("<w:body>")+8),s=s.substring(0,s.indexOf("</w:body>")),s=s.substring(0,s.lastIndexOf("<w:sectPr")),this.insertRaw(s),this._pageBreak&&r<e.length-1&&this.insertSectionBreak()});return Promise.all(t).then(()=>{})}async save(e,t){let n=this._files[0];if(!n||!n.file)throw new Error("JSZip file not properly loaded");let r=await n.file("word/document.xml").async("string"),s=r.indexOf("<w:body>")+8,l=r.lastIndexOf("<w:sectPr");r=r.replace(r.slice(s,l),this._body.join("")),await _(n,this._contentTypes),await x(n,this._media,this._files),await N(n,this._rel),await O(n,this._numbering),await y(n,this._style),n.file("word/document.xml",r);let i=await n.generateAsync({type:e,compression:"DEFLATE",compressionOptions:{level:4}});return t&&t(i),i}},Q=m;export{Q as default};
//# sourceMappingURL=index.esm.js.map
