{
  "version": 3,
  "sources": ["../src/index.js", "../src/merge-styles.js", "../src/merge-media.js", "../src/merge-relations-and-content-type.js", "../src/merge-bullets-numberings.js"],
  "sourcesContent": ["import JSZip from 'jszip'; \r\nimport * as Style from './merge-styles.js';\r\nimport * as Media from './merge-media.js';\r\nimport * as RelContentType from './merge-relations-and-content-type.js';\r\nimport * as bulletsNumbering from './merge-bullets-numberings.js';\r\n\r\n// // Check if running in a browser environment\r\n// const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\r\n\r\n// // Use the appropriate XML parser and serializer based on the environment\r\n// const XMLSerializer = isBrowser ? window.XMLSerializer : require('@xmldom/xmldom').XMLSerializer;\r\n// const DOMParser = isBrowser ? window.DOMParser : require('@xmldom/xmldom').DOMParser;\r\n\r\nclass DocxMerger {\r\n    constructor(options = {}, files = []) {\r\n        this._body = [];\r\n        this._header = [];\r\n        this._footer = [];\r\n        this._pageBreak = typeof options.pageBreak !== 'undefined' ? !!options.pageBreak : true;\r\n        this._Basestyle = options.style || 'source';\r\n        this._style = [];\r\n        this._numbering = [];\r\n        this._files = [];\r\n        this._contentTypes = {};\r\n        this._media = {};\r\n        this._rel = {};\r\n        this._builder = this._body;\r\n\r\n        this.initialize(options, files);\r\n    }\r\n\r\n    async initialize(options, files) {\r\n        for (const file of files) {\r\n            // Convert Uint8Array to ArrayBuffer if necessary\r\n            const arrayBuffer = file instanceof Uint8Array ? file.buffer : file;\r\n            const zip = await new JSZip().loadAsync(arrayBuffer);\r\n            this._files.push(zip);\r\n        }\r\n\r\n        if (this._files.length > 0) {\r\n            await this.mergeBody(this._files);\r\n        }\r\n    }\r\n\r\n    insertPageBreak() {\r\n        const pb = '<w:p> \\\r\n                    <w:r> \\\r\n                        <w:br w:type=\"page\"/> \\\r\n                    </w:r> \\\r\n                </w:p>';\r\n        this._builder.push(pb);\r\n    }\r\n\r\n    insertSectionBreak() {\r\n        const sb = '<w:p> \\\r\n                    <w:pPr> \\\r\n                        <w:sectPr> \\\r\n                            <w:type w:val=\"nextPage\"/> \\\r\n                        </w:sectPr> \\\r\n                    </w:pPr> \\\r\n                </w:p>';\r\n        this._builder.push(sb);\r\n    }\r\n\r\n    insertRaw(xml) {\r\n        this._builder.push(xml);\r\n    }\r\n\r\n    async mergeBody(files) {\r\n        this._builder = this._body;\r\n        await RelContentType.mergeContentTypes(files, this._contentTypes);\r\n        await Media.prepareMediaFiles(files, this._media);\r\n        await RelContentType.mergeRelations(files, this._rel);\r\n        await bulletsNumbering.prepareNumbering(files, this._numbering);\r\n        await bulletsNumbering.mergeNumbering(files, this._numbering);\r\n        await Style.prepareStyles(files, this._style);\r\n        await Style.mergeStyles(files, this._style);\r\n        const merge = files.map(async(zip, index) => {\r\n            let xmlString = await zip.file('word/document.xml').async('string');\r\n            xmlString = xmlString.substring(xmlString.indexOf('<w:body>') + 8);\r\n            xmlString = xmlString.substring(0, xmlString.indexOf('</w:body>'));\r\n            xmlString = xmlString.substring(0, xmlString.lastIndexOf('<w:sectPr'));\r\n            this.insertRaw(xmlString);\r\n            if (this._pageBreak && index < files.length-1){\r\n                this.insertSectionBreak();\r\n                // this.insertPageBreak();\r\n            }\r\n        });\r\n        return Promise.all(merge).then(() => {});\r\n    }\r\n\r\n    async save(type, callback) {\r\n        const zip = this._files[0];\r\n        \r\n        if (!zip || !zip.file) {\r\n            throw new Error('JSZip file not properly loaded');\r\n        }\r\n    \r\n        let xmlString = await zip.file('word/document.xml').async('string');\r\n    \r\n        const startIndex = xmlString.indexOf('<w:body>') + 8;\r\n        const endIndex = xmlString.lastIndexOf('<w:sectPr');\r\n    \r\n        xmlString = xmlString.replace(xmlString.slice(startIndex, endIndex), this._body.join(''));\r\n    \r\n        await RelContentType.generateContentTypes(zip, this._contentTypes);\r\n        await Media.copyMediaFiles(zip, this._media, this._files);\r\n        await RelContentType.generateRelations(zip, this._rel);\r\n        await bulletsNumbering.generateNumbering(zip, this._numbering);\r\n        await Style.generateStyles(zip, this._style);\r\n    \r\n        zip.file('word/document.xml', xmlString);\r\n    \r\n        const generatedFile = await zip.generateAsync({\r\n            type: type,\r\n            compression: 'DEFLATE',\r\n            compressionOptions: {\r\n                level: 4\r\n            }\r\n        });\r\n\r\n        if (callback) {\r\n            callback(generatedFile);\r\n        }\r\n\r\n        return generatedFile;\r\n    }\r\n}\r\n\r\nexport default DocxMerger;\r\n", "import { DOMParser, XMLSerializer } from '@xmldom/xmldom';\r\n\r\nconst prepareStyles = async function(files, _style) {\r\n    const merge = files.map(async (zip) => {\r\n        let xmlString = await zip.file('word/styles.xml').async('string');\r\n        const xml = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        const childNodes = xml.documentElement.childNodes;\r\n\r\n        for (let node = 0; node < childNodes.length; node++) {\r\n            if (childNodes[node].nodeType === 1) { // Element node\r\n                const styleId = childNodes[node].getAttribute('w:styleId');\r\n                if (!_style[styleId])\r\n                    _style[styleId] = childNodes[node].cloneNode(true);\r\n            }\r\n        }\r\n    });\r\n    return Promise.all(merge);\r\n};\r\n\r\nconst mergeStyles = async function(files, _style) {\r\n    const merge = files.map(async (zip) => {\r\n        let xmlString = await zip.file('word/styles.xml').async('string');\r\n        const xml = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        const serializer = new XMLSerializer();\r\n\r\n        const styles = xml.documentElement.cloneNode();\r\n\r\n        for (const node in _style) {\r\n            styles.appendChild(_style[node]);\r\n        }\r\n\r\n        const startIndex = xmlString.indexOf('<w:styles');\r\n        xmlString = xmlString.replace(xmlString.slice(startIndex), serializer.serializeToString(styles));\r\n\r\n        zip.file('word/styles.xml', xmlString);\r\n    });\r\n    return Promise.all(merge);\r\n};\r\n\r\nconst updateStyleRel_Content = async function(zip, fileIndex, styleId) {\r\n    let xmlString = await zip.file('word/document.xml').async('string');\r\n    xmlString = xmlString.replace(new RegExp('w:val=\"' + styleId + '\"', 'g'), 'w:val=\"' + styleId + '_' + fileIndex + '\"');\r\n    zip.file('word/document.xml', xmlString);\r\n};\r\n\r\nconst generateStyles = async function(zip, _style) {\r\n    let xmlString = await zip.file('word/styles.xml').async('string');\r\n    const startIndex = xmlString.indexOf('<w:style ');\r\n    const endIndex = xmlString.indexOf('</w:styles>');\r\n\r\n    xmlString = xmlString.replace(xmlString.slice(startIndex, endIndex), _style.join(''));\r\n\r\n    zip.file('word/styles.xml', xmlString);\r\n};\r\n\r\nexport { prepareStyles, mergeStyles, updateStyleRel_Content, generateStyles };", "import JSZip from 'jszip';\r\nimport { DOMParser, XMLSerializer } from '@xmldom/xmldom';\r\n\r\nasync function prepareMediaFiles(files, media) {\r\n    for (const file of files) {\r\n        const zip = await new JSZip().loadAsync(file);\r\n        const mediaFiles = zip.folder('word/media');\r\n        if (mediaFiles) {\r\n            mediaFiles.forEach((relativePath, file) => {\r\n                media[relativePath] = file;\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nconst updateMediaRelations = async function(zip, count, _media) {\r\n    let xmlString = await zip.file('word/_rels/document.xml.rels').async('string');\r\n    let xml = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n\r\n    const childNodes = xml.getElementsByTagName('Relationships')[0].childNodes;\r\n    const serializer = new XMLSerializer();\r\n\r\n    for (const node in childNodes) {\r\n        if (/^\\d+$/.test(node) && childNodes[node].getAttribute) {\r\n            const target = childNodes[node].getAttribute('Target');\r\n            if ('word/' + target === _media[count].oldTarget) {\r\n                _media[count].oldRelID = childNodes[node].getAttribute('Id');\r\n                childNodes[node].setAttribute('Target', _media[count].newTarget);\r\n                childNodes[node].setAttribute('Id', _media[count].oldRelID + '_' + count);\r\n            }\r\n        }\r\n    }\r\n\r\n    const startIndex = xmlString.indexOf('<Relationships');\r\n    xmlString = xmlString.replace(xmlString.slice(startIndex), serializer.serializeToString(xml.documentElement));\r\n\r\n    zip.file('word/_rels/document.xml.rels', xmlString);\r\n};\r\n\r\nconst updateMediaContent = async function(zip, count, _media) {\r\n    let xmlString = await zip.file('word/document.xml').async('string');\r\n    xmlString = xmlString.replace(new RegExp(_media[count].oldRelID + '\"', 'g'), _media[count].oldRelID + '_' + count + '\"');\r\n    zip.file('word/document.xml', xmlString);\r\n};\r\n\r\nasync function copyMediaFiles(zip, media, files) {\r\n    const mediaFolder = zip.folder('word/media');\r\n    if (!mediaFolder) {\r\n        throw new Error('Media folder not found in the zip');\r\n    }\r\n\r\n    for (const [relativePath, file] of Object.entries(media)) {\r\n        const content = await file.async('blob');\r\n        mediaFolder.file(relativePath, content);\r\n    }\r\n}\r\n\r\nexport { prepareMediaFiles, updateMediaRelations, updateMediaContent, copyMediaFiles };", "import { DOMParser, XMLSerializer } from '@xmldom/xmldom';\r\n\r\nconst mergeContentTypes = function(files, _contentTypes) {\r\n    const merge = files.map(async (zip) => {\r\n        const xmlString = await zip.file('[Content_Types].xml').async('string');\r\n        const xml = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n\r\n        const childNodes = xml.getElementsByTagName('Types')[0].childNodes;\r\n\r\n        for (const node in childNodes) {\r\n            if (/^\\d+$/.test(node) && childNodes[node].getAttribute) {\r\n                const contentType = childNodes[node].getAttribute('ContentType');\r\n                if (!_contentTypes[contentType])\r\n                    _contentTypes[contentType] = childNodes[node].cloneNode();\r\n            }\r\n        }\r\n    });\r\n    return Promise.all(merge);\r\n};\r\n\r\nconst mergeRelations = async function(files, _rel) {\r\n    const merge = files.map(async (zip) => {\r\n        let xmlString = await zip.file('word/_rels/document.xml.rels').async('string');\r\n        const xml = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        const childNodes = xml.documentElement.childNodes;\r\n\r\n        for (let node = 0; node < childNodes.length; node++) {\r\n            if (childNodes[node].nodeType === 1) { // Element node\r\n                const Id = childNodes[node].getAttribute('Id');\r\n                if (!_rel[Id])\r\n                    _rel[Id] = childNodes[node].cloneNode();\r\n            }\r\n        }\r\n    });\r\n    return Promise.all(merge);\r\n};\r\n\r\nconst generateContentTypes = async function(zip, _contentTypes) {\r\n    let xmlString = await zip.file('[Content_Types].xml').async('string');\r\n    const xml = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n    const serializer = new XMLSerializer();\r\n\r\n    const types = xml.documentElement.cloneNode();\r\n\r\n    for (const node in _contentTypes) {\r\n        types.appendChild(_contentTypes[node]);\r\n    }\r\n\r\n    const startIndex = xmlString.indexOf('<Types');\r\n    xmlString = xmlString.replace(xmlString.slice(startIndex), serializer.serializeToString(types));\r\n\r\n    zip.file('[Content_Types].xml', xmlString);\r\n};\r\n\r\nconst generateRelations = async function(zip, _rel) {\r\n    let xmlString = await zip.file('word/_rels/document.xml.rels').async('string');\r\n    const xml = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n    const serializer = new XMLSerializer();\r\n\r\n    const rels = xml.documentElement.cloneNode();\r\n\r\n    for (const node in _rel) {\r\n        rels.appendChild(_rel[node]);\r\n    }\r\n\r\n    const startIndex = xmlString.indexOf('<Relationships');\r\n    xmlString = xmlString.replace(xmlString.slice(startIndex), serializer.serializeToString(rels));\r\n\r\n    zip.file('word/_rels/document.xml.rels', xmlString);\r\n};\r\n\r\nexport { mergeContentTypes, mergeRelations, generateContentTypes, generateRelations };", "import JSZip from 'jszip';\r\nimport { DOMParser, XMLSerializer } from '@xmldom/xmldom';\r\n\r\nasync function prepareNumbering(files, _numbering) {\r\n    const merge = files.map(async (zip) => {\r\n        let xmlString = await zip.file('word/numbering.xml').async('string');\r\n        const xml = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        const childNodes = xml.documentElement.childNodes;\r\n\r\n        for (let node = 0; node < childNodes.length; node++) {\r\n            if (childNodes[node].nodeType === 1) { // Element node\r\n                const abstractNumId = childNodes[node].getAttribute('w:abstractNumId');\r\n                if (!_numbering[abstractNumId])\r\n                    _numbering[abstractNumId] = childNodes[node].cloneNode(true);\r\n            }\r\n        }\r\n        _numbering.push(xmlString);\r\n    });\r\n    return Promise.all(merge);\r\n}\r\n\r\nasync function mergeNumbering(files, _numbering) {\r\n    const merge = files.map(async (zip) => {\r\n        let xmlString = await zip.file('word/numbering.xml').async('string');\r\n        const xml = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        const serializer = new XMLSerializer();\r\n\r\n        const numbering = xml.documentElement.cloneNode();\r\n\r\n        for (const node in _numbering) {\r\n            numbering.appendChild(_numbering[node]);\r\n        }\r\n\r\n        const startIndex = xmlString.indexOf('<w:numbering');\r\n        xmlString = xmlString.replace(xmlString.slice(startIndex), serializer.serializeToString(numbering));\r\n\r\n        zip.file('word/numbering.xml', xmlString);\r\n    });\r\n    return Promise.all(merge);\r\n}\r\n\r\nasync function generateNumbering(zip, _numbering) {\r\n    let xmlBin = zip.file(\"word/numbering.xml\");\r\n    if (!xmlBin) {\r\n        throw new Error('Numbering file not found in the zip');\r\n    }\r\n\r\n    let xmlString = await xmlBin.async('string');\r\n    const startIndex = xmlString.indexOf(\"<w:abstractNum \");\r\n    const endIndex = xmlString.indexOf(\"</w:numbering>\");\r\n\r\n    xmlString = xmlString.replace(xmlString.slice(startIndex, endIndex), _numbering.join(''));\r\n\r\n    zip.file(\"word/numbering.xml\", xmlString);\r\n}\r\n\r\nexport { prepareNumbering, mergeNumbering, generateNumbering };"],
  "mappings": "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",
  "names": ["JSZip", "DOMParser", "XMLSerializer", "prepareStyles", "files", "_style", "merge", "zip", "xmlString", "childNodes", "node", "styleId", "mergeStyles", "xml", "serializer", "styles", "startIndex", "generateStyles", "zip", "_style", "xmlString", "startIndex", "endIndex", "JSZip", "DOMParser", "XMLSerializer", "prepareMediaFiles", "files", "media", "file", "mediaFiles", "relativePath", "copyMediaFiles", "zip", "media", "files", "mediaFolder", "relativePath", "file", "content", "DOMParser", "XMLSerializer", "mergeContentTypes", "files", "_contentTypes", "merge", "zip", "xmlString", "childNodes", "node", "contentType", "mergeRelations", "_rel", "Id", "generateContentTypes", "xml", "serializer", "types", "startIndex", "generateRelations", "rels", "DOMParser", "XMLSerializer", "prepareNumbering", "files", "_numbering", "merge", "zip", "xmlString", "childNodes", "node", "abstractNumId", "mergeNumbering", "xml", "serializer", "numbering", "startIndex", "generateNumbering", "xmlBin", "endIndex", "DocxMerger", "options", "files", "file", "arrayBuffer", "zip", "JSZip", "pb", "sb", "xml", "mergeContentTypes", "prepareMediaFiles", "mergeRelations", "prepareNumbering", "mergeNumbering", "prepareStyles", "mergeStyles", "merge", "index", "xmlString", "type", "callback", "startIndex", "endIndex", "generateContentTypes", "copyMediaFiles", "generateRelations", "generateNumbering", "generateStyles", "generatedFile", "src_default"]
}
